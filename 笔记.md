### **BEM** 命名规范

Block__Element--modifile

块，块中的元素名，当前类主要是什么修饰作用？color?red?display？

### 常见的块级元素、行内元素、行内块元素

一、块级元素 block

特点：
自动换行
独占一行
可设置宽高
默认宽度为父元素的宽度
2.常见块级元素
div、p、h1~h6、**ul、ol**、dl、**li**、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等

form

3.注意
块级元素可以嵌套任意元素
块级文字元素中不能放入其他块级元素，比如： p中不要嵌套div、p、h



二、行内元素 inline
1.特点
无法自动换行
一行可放多个
不可设置宽高
默认宽度是本身内容宽度
行内元素的paddding可以设置
margin只能够设置水平方向的边距，即：margin-left和margin-right，设置margin-top和margin-bottom无效



2.常见行内元素
span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）



三、行内块元素 inline-block
1.特点
综合块级元素与行内元素的特性，可设宽高（默认是内容宽高），也可以设置内外边距



2.常见行内块元素
img 、**input** 、td
四、标签之间的转换
display：inline（转为行内元素）/inline-block（转为行内块元素）/block（转为块元素）/none（隐藏 不显示）

注意：当元素浮动（float）时会转化成行内块元素特点。


### SVG标签学习

path生成任意形状

### 点击搜索过渡，搜索变大，创作中心消失

- 用一个ul包裹起来这里面的两个li；
- ul给定宽度和高度，然后和右边的三个li一起右浮动起来；
- ul里面的两个li，一个左浮动一个右浮动，li里面的内容居中使用flex布局
- 点击之后，第一个li宽度，边框通过添加className变化，右边的li通过transform: translateX(200px)移动到右边；
- ul添加overflow: hidden隐藏后面的出去的li

### 疑问？已经在flex的子盒子，再开启BFC

- 当前元素已经flex: 1

- 右浮动一个盒子，浮动的盒子就会跑去当前盒子下方的浮动流，因为你规定当前的盒子占1

  ```html
  下面的情况先让containerB自适应
  <style>
      .containerA {
          display: flex;
      }
      .left {
          width: 100px;
      }
      .containerB {
          flex: 1;
      }
  </style>
  <div class="containerA">
      <div class="left">left</div>
      <div class="containerB">
      	<div class="middle">middle</div>
          <div class="right">right</div>
      </div>
  </div>
  
  我想要给containerB里面的middle自适应，用BFC方法是无效的
  父元素是flex布局,子元素的float、clear和vertical-align属性将会失效
  <style>
      .right {
          float: right;
      }
      .middle {
          overflow: hidden;
      }
  </style>
  上面的操作无非是想让middle自适应，做两栏自适应就可以了，有时候写CSS就是转不过弯来！！
  ```

  

### sticky定位

参见张鑫旭：https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/

单词sticky的中文意思是“粘性的”，`position:sticky`表现也符合这个粘性的表现。基本上，可以看出是`position:relative`和`position:fixed`的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。

//zxx: position:sticky要想生效，top属性或则left属性（看滚动方向）是必须要有明确的计算值的，否则fixed的表现不会出现。



```
fixed
```

元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`、`perspective`、`filter` 或 `backdrop-filter` 属性非 `none` 时，容器由视口改为该祖先。

## 解决 fixed定位根据元素的问题

- 父元素绝对定位，再加transition: all 0.3s linear; 给个宽度width: xxpx, 绝对定位在一个位置 absolute
- fixed元素，top: xxpx, right不要给就可以实现；不能给margin!!!
- 实现固定定位滚动以后不动，并且相对位置还是一个响应式的位置，会随着页面的变化而变化！！！

### useRef

### Manipulating the DOM with a ref 

It’s particularly common to use a ref to manipulate the [DOM.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API) React has built-in support for this.

First, declare a ref object with an initial value of `null`:

```
import { useRef } from 'react';



function MyComponent() {

  const inputRef = useRef(null);

  // ...
```

Then pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate:

```
  // ...

  return <input ref={inputRef} />;
```

After React creates the DOM node and puts it on the screen, React will set the `current` property of your ref object to that DOM node. Now you can access the `<input>`’s DOM node and call methods like [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus):

```
  function handleClick() {

    inputRef.current.focus();

  }
```

### display：none与visibility: hidden

1. 前者消失后不占用标准流，后者占用--重绘重排？

display:none是彻底消失， 不在文档流中占位， 浏览器也不会解析该元素； **display:none切换时会产生回流**。 visibility:hidden是视觉上消失了， 在文档流中占位，浏览器会解析该元素； **不会产生回流**

2. 前者过渡无效果，后者可以加过渡

3. visibility: hidden;是具继承性的， 如果父级元素设置了visibility: hidden; 那么子集元素也会看不见。

但是如果子集元素设置了visibility: visible; 则该子元素又会显示出来 这个和display:none有着本质的区别

“*visibility: hidden; 的元素不会触发绑定的事件。* opacity:0; 的元素会触发绑定的事件

### 全部--前端--后端选择框在滚动的时候哦改变位置的思路

1. useRef获取到input和ul的DOM元素
2. getBoundingClientRect获取到input元素相对于client的位置
3. 判断input的y是否大于ul的高度，如果高于就放上面，否则放下面
4. 触发事件使用IntersectionObserver API---scroll还要节流---性能问题

### useEffect钩子---奇怪，第一遍的时候还记得，过了半个月就忘记这个钩子了

effect（副作用）是react函数组件用来替代生命周期的函数。你可以把 `useEffect Hook` 看做 `componentDidMount`，`componentDidUpdate` 和 `componentWillUnmount` 这三个函数的组合。

#### 用法

它的参数如下： `useEffect(callback[,[]])`

第一个参数接受一个`callback`回调函数，里面可以写执行业务代码

第二个参数可省略，它接受一个数组，可以是空数组，也包含了`state`数据

#### 说明

1. 当不传递第二个参数时，每次render都会执行一遍callback函数，相当于包含第一遍render的`componentDidUpdate`

2. 当传递第二个参数且是空数组时，只有第一次render才会执行callback，类似于`componentDidMount`

3. 不管是否传递第二个参数，只要在`callback`中return 一个函数，就相当于告诉react此组件挂掉之前执行什么操作，类似于`componentWillUnMount`

疑问：useEffect为什么会执行两次？

### 路由

### BrowserRouter

> 这一种很自然，比如 `/` 对应 `Home页` ，`/about` 对应 `About 页`，但是`这样的设计需要服务器端渲染`，因为`用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about的访问返回 HTML`。BrowserRouter支持这种URL。 ①基于history模式：页面跳转原理是使用了HTML5为浏览器全局的history对象新增了两个API，包括 history.pushState、history.replaceState；和vue router的history模式实现一致
>  ②更加优雅： 直接拼接路径；如：[www.abc.com/xx](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2Fxx)
>  ③后端需做请求处理： 切换路由后，请求接口路径会发生变化，后端需要配合，做处理

### HashRouter

> 这一种看起来不自然，但是实现更简单。`只有一个路径 /，通过 URL 后面的 # 部分来决定路由`，/#/ 对应 Home 页，/#/about 对应 About 页。因为URL中#之后的部分是不会发送给服务器的，所以，`无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML`就可以，`然后由浏览器端解析 # 后的部分，完成浏览器端渲染`。HashRouter支持这种URL。
>  ①**基于hash模式**：页面跳转原理是使用了location.hash、location.replace；和[vue](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Ffrom%3Dpc_blog_highlight%26q%3Dvue) router的hash模式实现一致
>  ②**比较丑**：在域名后，先拼接/#，再拼接路径；也就是利用锚点，实现路由的跳转；如：[www.abc.com/#/xx](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2F%23%2Fxx)

## 疑问：input失去焦点的时候，visibility为hidden，拿不到ul里面的内容

点击li里面的a，触发事件，a的点击后触发，触发的时候都拿不到任何内容了

**因为input先触发失去焦点事件，然后a已经被设置为visibility: hidden了，这时候a不能够触发点击事件，所以换为opcity控制元素的显示和隐藏，opcity：0的元素能够触发点击事件**。

但是opacity： 0本身在DOM中，隐藏的时候也会触发事件！！！

将隐藏下拉菜单的函数延迟触发，解决问题

```
  /* 隐藏下拉菜单 */
  const hiddenEle = () => {
    setTimeout(() => {
      setIsDisplay(false)
    }, 100)
  }
```

为什么可以解决？a延迟隐藏，这时候拿到了a的点击事件之后a才消失。

除了这种方法还有什么能够保证a点击触发排在hidden之后

## 疑问：创作中心的下拉菜单定位在那个位置怎么实现

也即：不是父子关系的两个盒子的定位如何实现配合？不能绝对定位和相对定位配合的时候用js去处理！！

！！！！绝对定位的盒子脱离标准流并且不会影响任意的盒子，位置跟随着父元素的位置走，所以使用绝对定位！！！

### Viewport

在电脑图形学里面，视口代表了一个可看见的多边形区域（通常来说是矩形）。在浏览器范畴里，它代表的是浏览器中网站可见内容的部分。视口外的内容在被滚动进来前都是不可见的。

视口当前可见的部分叫做**可视视口**（visual viewport）。可视视口可能会比**布局视口**（layout viewport）更小，因为当用户缩小浏览器缩放比例时，**布局视口不变，而可视视口变小了**。

### Element.getBoundingClientRect()

返回值是一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，是包含整个元素的最小矩形（包括 `padding` 和 `border-width`）。该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

就是相对于整个浏览器的左上角

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      height: 5000px;
    }
    p {
      margin-left: 1000px;
      background-color: yellow;
      width: 100px;
    }
    div {
      background-color: skyblue;
      width: 100px;
      height: 100px;
      position: fixed;
      /* right: 100px; */
    }
  </style>
</head>
<body>
  <p>789</p>
  <div>123456789</div>
  <script>
    const div =document.querySelector('div')
    const p = document.querySelector('p')
    console.log(div.getBoundingClientRect().right)
    console.log(document.body.clientWidth)
    div.style.right = document.body.clientWidth - p.getBoundingClientRect().right + 'px'
  </script>
</body>
</html>
```



## 疑问：能否用sticky实现滚动后固定定位的效果？

```
fixed
```

元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`、`perspective`、`filter` 或 `backdrop-filter` 属性非 `none` 时，容器由视口改为该祖先。

```
sticky
```

元素根据正常文档流进行定位，然后相对它的*最近滚动祖先*（nearest scrolling ancestor）和 [containing block](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block)（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 `top`、`right`、`bottom` 和 `left` 的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 `overflow` 是 `hidden`、`scroll`、`auto` 或 `overlay` 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 [Github issue on W3C CSSWG](https://github.com/w3c/csswg-drafts/issues/865)）。

## React-router配置

```react
import { createBrowserRouter, Navigate } from "react-router-dom";
import App from '../App'
import HomeMainContent from "../common/homeMainContent";

const router = createBrowserRouter([
  {
    path: '/',
    element: <App></App>,
    children: [
      {
        path: '',
        element: <HomeMainContent></HomeMainContent>
      },
      {
        path: '/recommended',
        element: <HomeMainContent></HomeMainContent>
      },
      {
        path: '/backend',
        element: <HomeMainContent></HomeMainContent>
      }
    ]
  }
])

export default router
```

怎么让根路径匹配APP显示的时候包含自己的子组件？让根路径的有一个空路径匹配就可以了！！！

## 疑问：怎么将鼠标经过的时候菜单变色封装为一个hook





## 解决：OutLet组件所在的父组件需要传递数据给OutLet跳转后的组件，怎么传递？

使用useContext-----类似Vue3的依赖注入

```
1.首先，你需要创建这个 context，并 将其从一个文件中导出，这样你的组件才可以使用它：
import { createContext } from 'react';

export const LevelContext = createContext(1);

2.从 React 中引入 useContext Hook 以及你刚刚创建的 context:
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}

3.把它们用 context provider 包裹起来  以提供 LevelContext 给它们：
import { LevelContext } from './LevelContext.js';

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

## CSS头像剪裁

```css
.pinscomment__img--header {
  width: 4rem;
  height: 4rem;
  border-radius: 50%;
}
```

## 重点：处理文字溢出隐藏---在flex布局模式内的p，文字后多余显示省略号

父盒子设置：

因为之前white-space: nowrap让文字强制在一行显示的时候，flex布局会自动变大自己当前所在的盒子，导致布局错误

```
white-space: nowrap;  // 所有的空格都不换行--强制一行显示，换行符也会被web解释为空格
overflow: hidden;  // 溢出隐藏
text-overflow: hidden;  // 文字溢出的时候使用省略号装饰
```

这样没有强制在一行显示，布局流会自动流下去以适应页面变化

```
font-size: 13px;
line-height: 22px;
display: -webkit-box;  // box盒子---盒子的高度由行高乘以实际的行数决定
overflow: hidden;
text-overflow: ellipsis;  // 省略
-webkit-box-orient: vertical;
-webkit-line-clamp: 1;  // 将文本的内容限制为指定的行数，显示为指定的行数之后还会显示省略号，所以text-overflow可以省略了
```

**`-webkit-line-clamp`** CSS 属性可以把[块容器](https://developer.mozilla.org/zh-CN/docs/Glossary/Block)中的内容限制为指定的行数。

它只有在 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 属性设置成 `-webkit-box` 或者 `-webkit-inline-box` 并且 [`box-orient`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-orient) 属性设置成 `vertical`时才有效果。

在大部分情况下，也需要设置 [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 属性为 `hidden`，否则，里面的内容不会被裁减，并且**在内容显示为指定行数后还会显示省略号**。

## CSS实现三角形

一个盒子三个边框设置

```
border: 2px solid transparent;
```

需要三角的那个反方向设置

```
border: 2px solid #ccc;
```

## Home主页获取文章列表可以用router的loader来做

## artical页面通过urlParams获取文章id拿文章数据也是通过loader来做

loader到底是什么？

1. 当前路由跳转到的目标页面写一个loader函数，函数参数位置能拿到params参数
2. loader里面拿到params参数---去做进一步的处理，处理以后有一个返回值
3. 在路由配置js文件里面声明loader为在组件里面写的loader
4. 组件生成的时候使用useLoaderData() API，返回的参数就是你在loader里面返回的参数

为什么这么设计？

1. 数据-页面-url路径相互耦合
2. 一些数据需要在路由匹配，加载组件之前获得，然后交给路由所要渲染的组件
3. loader意为，loader组件之前，你要进行的所有操作
4. useLoaderData API就是将你在loader执行完之后返回的数据再传递给了组件内部

**Add a loader to the contact page and access data with `useLoaderData`**

```react
import { Form, useLoaderData } from "react-router-dom";
import { getContact } from "../contacts";

export async function loader({ params }) {
  const contact = await getContact(params.contactId);
  return { contact };
}

export default function Contact() {
  const { contact } = useLoaderData();
  // existing code
}
```

👉 **Configure the loader on the route**

```react
/* existing code */
import Contact, {
  loader as contactLoader,
} from "./routes/contact";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
        loader: contactLoader,
      },
    ],
  },
]);

/* existing code */
```

## 封装一个axios来请求服务器端的接口数据

## 文章的内容怎么显示的？？？？markdown文档是怎么被转换为页面上的元素的，掘金为什么可以那么写？

SVG元素怎么使用，path怎么根据路径绘制出合适的形状？



## 组件嵌套不在父子，很深，点击立即登录显示登陆注册组件的时候用PubSub传递消息



## React在form里面写东西页面跳转和发送请求的问题

用Form

ajax请求的格式，不然会不被识别从而抛出错误

```
xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8')
```

## AXIOS源码里面请求拦截器怎么写的



## 编程式路由导航

http://www.reactrouter.cn/docs/getting-started/tutorial#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%AF%BC%E8%88%AA

官方推荐用redirect

## 疑问：个人中心的userInfo怎么在文章发表组件里面点击一次之后传递到文章发表组件

用PubSub传递的时候存在用户初次登录发表不成功的问题，就是打印的时候得到的用户信息并不是实时同步的，为什么？因为后面的组件还没挂载上去，因为属于不同的路由，后面的组件还没有订阅这个消息，前面的组件就已经发布完了所有的消息。

解决---还是用context，把用户的登录信息提升到最上层的组件，任意路由都能访问到。

## ---还有全局请求拦截器，那样写不行，token在有时候还是带不上，还是需要看axios全局请求拦截器怎么写的

## 重要！！以前没遇到过。疑问：怎么让点击按钮发送Ajax请求排在input失去焦点之前触发

1. 加一个定时器延迟执行样式变化效果

2. 正式版解决方案：

   当我们点击按钮的时候，文本框失焦，这是浏览器的默认事件。当你点击按钮的时候，会触发按钮的**touchstart/mousedown**事件，**touchstart/mousedown事件的默认行为是使除了你点击的对象之外的有焦点的对象失去焦点**。所以**只要在你不想触发失去焦点事件的那个元素上面**的touchstart/mousedown事件中阻止默认事件发生就可以了！

   ```
   onMouseDown={(event) => { event.preventDefault() }}
   ```


## 重点：下拉菜单的实现：

Node.prototype.contains()

`contains`方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。

- 参数节点为当前节点。
- 参数节点为当前节点的子节点。
- 参数节点为当前节点的后代节点。

监听事件，排除如果不是在当前节点下面触发就隐藏？

----给Document添加点击事件，如果当前组件的顶层DOM不包含触发事件节点的DOM就说明点击了这个DOM外面，让元素隐藏就可以了

```react
import React, { useEffect, useRef } from 'react'
import './index.css'
import useNotifacationList from '../../../../useHooks/headerImgMemberNotifacation'

export default function HeaderMenuDown({ homeMenuList }) {
  const menu = useRef()
  /* 鼠标点击控制下拉菜单的显示与隐藏 */
  const { isDisplay, display, noDisplay } = useNotifacationList()

  const changeDisplay = () => {
    if (isDisplay) {
      noDisplay()
    } else {
      display()
    }
  }

  useEffect(() => {
    document.addEventListener('click', (event) => {
      /* 只要当前组件里面最大的盒子不包含触发事件的那个节点，就说明鼠标点击的是盒子外面 */
      if (!menu.current.contains(event.target)) {
        noDisplay()
      }
    })
  }, [])
  return (
    <div
      className='headerMenuDown__div--container'
      ref={menu}
    >
      <div
        className='headerMenuDown__div--center'
        onClick={changeDisplay}
      ><span>首页</span>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"
          className={isDisplay ? 'headerMenuDown__svg--centerarrowactive' : ''}
        >
          <path d="M2.45025 4.82431C2.17422 4.49957 2.40501 4.00049 2.83122 4.00049H9.16878C9.59498 4.00049 9.82578 4.49957 9.54975 4.82431L6.38097 8.55229C6.1813 8.78719 5.8187 8.78719 5.61903 8.55229L2.45025 4.82431Z"
            className={isDisplay ? 'headerMenuDown__path--centerarrowactive' : ''}
          ></path></svg>
      </div>
      <ul
        className={'headerMenuDown__ul--absolute ' + (isDisplay ? 'headerMenuDown__ul--display' : '')}
      >
        {homeMenuList.map((item) => {
          return <li key={item.id}><a href="/">{item.title}</a></li>
        })}
      </ul>
    </div>
  )
}

```

## overflow----CSS

## 重点：怎么在flex布局下面开启水平滚动条：

- flex 的container开启flex，默认宽度就是屏幕的100%
- flex的所有子元素添加`flex-shrink: 0;`表示空间不足的时候每个子盒子都不缩小，这样所有的子盒子都会占一行
- container添加`overflow-x: auto`就会显示滚动条
