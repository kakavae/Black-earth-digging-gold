### **BEM** 命名规范

Block__Element--modifile

块，块中的元素名，当前类主要是什么修饰作用？color?red?display？

### 常见的块级元素、行内元素、行内块元素

一、块级元素 block

特点：
自动换行
独占一行
可设置宽高
默认宽度为父元素的宽度
2.常见块级元素
div、p、h1~h6、**ul、ol**、dl、**li**、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等

form

3.注意
块级元素可以嵌套任意元素
块级文字元素中不能放入其他块级元素，比如： p中不要嵌套div、p、h



二、行内元素 inline
1.特点
无法自动换行
一行可放多个
不可设置宽高
默认宽度是本身内容宽度
行内元素的paddding可以设置
margin只能够设置水平方向的边距，即：margin-left和margin-right，设置margin-top和margin-bottom无效



2.常见行内元素
span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）



三、行内块元素 inline-block
1.特点
综合块级元素与行内元素的特性，可设宽高（默认是内容宽高），也可以设置内外边距



2.常见行内块元素
img 、**input** 、td
四、标签之间的转换
display：inline（转为行内元素）/inline-block（转为行内块元素）/block（转为块元素）/none（隐藏 不显示）

注意：当元素浮动（float）时会转化成行内块元素特点。


### SVG标签学习

path生成任意形状

### 点击搜索过渡，搜索变大，创作中心消失

- 用一个ul包裹起来这里面的两个li；
- ul给定宽度和高度，然后和右边的三个li一起右浮动起来；
- ul里面的两个li，一个左浮动一个右浮动，li里面的内容居中使用flex布局
- 点击之后，第一个li宽度，边框通过添加className变化，右边的li通过transform: translateX(200px)移动到右边；
- ul添加overflow: hidden隐藏后面的出去的li

### 疑问？已经在flex的子盒子，再开启BFC

- 当前元素已经flex: 1

- 右浮动一个盒子，浮动的盒子就会跑去当前盒子下方的浮动流，因为你规定当前的盒子占1

  ```html
  下面的情况先让containerB自适应
  <style>
      .containerA {
          display: flex;
      }
      .left {
          width: 100px;
      }
      .containerB {
          flex: 1;
      }
  </style>
  <div class="containerA">
      <div class="left">left</div>
      <div class="containerB">
      	<div class="middle">middle</div>
          <div class="right">right</div>
      </div>
  </div>
  
  我想要给containerB里面的middle自适应，用BFC方法是无效的
  父元素是flex布局,子元素的float、clear和vertical-align属性将会失效
  <style>
      .right {
          float: right;
      }
      .middle {
          overflow: hidden;
      }
  </style>
  上面的操作无非是想让middle自适应，做两栏自适应就可以了，有时候写CSS就是转不过弯来！！
  ```

  

### sticky定位

参见张鑫旭：https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/

单词sticky的中文意思是“粘性的”，`position:sticky`表现也符合这个粘性的表现。基本上，可以看出是`position:relative`和`position:fixed`的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。

//zxx: position:sticky要想生效，top属性或则left属性（看滚动方向）是必须要有明确的计算值的，否则fixed的表现不会出现。



```
fixed
```

元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`、`perspective`、`filter` 或 `backdrop-filter` 属性非 `none` 时，容器由视口改为该祖先。

### useRef

### Manipulating the DOM with a ref 

It’s particularly common to use a ref to manipulate the [DOM.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API) React has built-in support for this.

First, declare a ref object with an initial value of `null`:

```
import { useRef } from 'react';



function MyComponent() {

  const inputRef = useRef(null);

  // ...
```

Then pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate:

```
  // ...

  return <input ref={inputRef} />;
```

After React creates the DOM node and puts it on the screen, React will set the `current` property of your ref object to that DOM node. Now you can access the `<input>`’s DOM node and call methods like [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus):

```
  function handleClick() {

    inputRef.current.focus();

  }
```

### display：none与visibility: hidden

1. 前者消失后不占用标准流，后者占用--重绘重排？

display:none是彻底消失， 不在文档流中占位， 浏览器也不会解析该元素； **display:none切换时会产生回流**。 visibility:hidden是视觉上消失了， 在文档流中占位，浏览器会解析该元素； **不会产生回流**

2. 前者过渡无效果，后者可以加过渡

3. visibility: hidden;是具继承性的， 如果父级元素设置了visibility: hidden; 那么子集元素也会看不见。

但是如果子集元素设置了visibility: visible; 则该子元素又会显示出来 这个和display:none有着本质的区别

“*visibility: hidden; 的元素不会触发绑定的事件。* opacity:0; 的元素会触发绑定的事件

### 全部--前端--后端选择框在滚动的时候哦改变位置的思路

1. useRef获取到input和ul的DOM元素
2. getBoundingClientRect获取到input元素相对于client的位置
3. 判断input的y是否大于ul的高度，如果高于就放上面，否则放下面
4. 触发事件使用IntersectionObserver API---scroll还要节流---性能问题

### useEffect钩子---奇怪，第一遍的时候还记得，过了半个月就忘记这个钩子了

effect（副作用）是react函数组件用来替代生命周期的函数。你可以把 `useEffect Hook` 看做 `componentDidMount`，`componentDidUpdate` 和 `componentWillUnmount` 这三个函数的组合。

#### 用法

它的参数如下： `useEffect(callback[,[]])`

第一个参数接受一个`callback`回调函数，里面可以写执行业务代码

第二个参数可省略，它接受一个数组，可以是空数组，也包含了`state`数据

#### 说明

1. 当不传递第二个参数时，每次render都会执行一遍callback函数，相当于包含第一遍render的`componentDidUpdate`

2. 当传递第二个参数且是空数组时，只有第一次render才会执行callback，类似于`componentDidMount`

3. 不管是否传递第二个参数，只要在`callback`中return 一个函数，就相当于告诉react此组件挂掉之前执行什么操作，类似于`componentWillUnMount`

疑问：useEffect为什么会执行两次？

### 路由

### BrowserRouter

> 这一种很自然，比如 `/` 对应 `Home页` ，`/about` 对应 `About 页`，但是`这样的设计需要服务器端渲染`，因为`用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about的访问返回 HTML`。BrowserRouter支持这种URL。 ①基于history模式：页面跳转原理是使用了HTML5为浏览器全局的history对象新增了两个API，包括 history.pushState、history.replaceState；和vue router的history模式实现一致
>  ②更加优雅： 直接拼接路径；如：[www.abc.com/xx](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2Fxx)
>  ③后端需做请求处理： 切换路由后，请求接口路径会发生变化，后端需要配合，做处理

### HashRouter

> 这一种看起来不自然，但是实现更简单。`只有一个路径 /，通过 URL 后面的 # 部分来决定路由`，/#/ 对应 Home 页，/#/about 对应 About 页。因为URL中#之后的部分是不会发送给服务器的，所以，`无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML`就可以，`然后由浏览器端解析 # 后的部分，完成浏览器端渲染`。HashRouter支持这种URL。
>  ①**基于hash模式**：页面跳转原理是使用了location.hash、location.replace；和[vue](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Ffrom%3Dpc_blog_highlight%26q%3Dvue) router的hash模式实现一致
>  ②**比较丑**：在域名后，先拼接/#，再拼接路径；也就是利用锚点，实现路由的跳转；如：[www.abc.com/#/xx](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2F%23%2Fxx)

## 疑问：input失去焦点的时候，visibility为hidden，拿不到ul里面的内容

点击li里面的a，触发事件，a的点击后触发，触发的时候都拿不到任何内容了

**因为input先触发失去焦点事件，然后a已经被设置为visibility: hidden了，这时候a不能够触发点击事件，所以换为opcity控制元素的显示和隐藏，opcity：0的元素能够触发点击事件**。

但是opacity： 0本身在DOM中，隐藏的时候也会触发事件！！！

将隐藏下拉菜单的函数延迟触发，解决问题

```
  /* 隐藏下拉菜单 */
  const hiddenEle = () => {
    setTimeout(() => {
      setIsDisplay(false)
    }, 100)
  }
```

为什么可以解决？a延迟隐藏，这时候拿到了a的点击事件之后a才消失。

除了这种方法还有什么能够保证a点击触发排在hidden之后

## 疑问：创作中心的下拉菜单定位在那个位置怎么实现

也即：不是父子关系的两个盒子的定位如何实现配合？不能绝对定位和相对定位配合的时候用js去处理！！

### Viewport

在电脑图形学里面，视口代表了一个可看见的多边形区域（通常来说是矩形）。在浏览器范畴里，它代表的是浏览器中网站可见内容的部分。视口外的内容在被滚动进来前都是不可见的。

视口当前可见的部分叫做**可视视口**（visual viewport）。可视视口可能会比**布局视口**（layout viewport）更小，因为当用户缩小浏览器缩放比例时，**布局视口不变，而可视视口变小了**。

### Element.getBoundingClientRect()

返回值是一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，是包含整个元素的最小矩形（包括 `padding` 和 `border-width`）。该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

就是相对于整个浏览器的左上角

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      height: 5000px;
    }
    p {
      margin-left: 1000px;
      background-color: yellow;
      width: 100px;
    }
    div {
      background-color: skyblue;
      width: 100px;
      height: 100px;
      position: fixed;
      /* right: 100px; */
    }
  </style>
</head>
<body>
  <p>789</p>
  <div>123456789</div>
  <script>
    const div =document.querySelector('div')
    const p = document.querySelector('p')
    console.log(div.getBoundingClientRect().right)
    console.log(document.body.clientWidth)
    div.style.right = document.body.clientWidth - p.getBoundingClientRect().right + 'px'
  </script>
</body>
</html>
```



## 疑问：能否用sticky实现滚动后固定定位的效果？

```
fixed
```

元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`、`perspective`、`filter` 或 `backdrop-filter` 属性非 `none` 时，容器由视口改为该祖先。

```
sticky
```

元素根据正常文档流进行定位，然后相对它的*最近滚动祖先*（nearest scrolling ancestor）和 [containing block](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block)（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 `top`、`right`、`bottom` 和 `left` 的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 `overflow` 是 `hidden`、`scroll`、`auto` 或 `overlay` 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为（详情见 [Github issue on W3C CSSWG](https://github.com/w3c/csswg-drafts/issues/865)）。

## React-router配置

```react
import { createBrowserRouter, Navigate } from "react-router-dom";
import App from '../App'
import HomeMainContent from "../common/homeMainContent";

const router = createBrowserRouter([
  {
    path: '/',
    element: <App></App>,
    children: [
      {
        path: '',
        element: <HomeMainContent></HomeMainContent>
      },
      {
        path: '/recommended',
        element: <HomeMainContent></HomeMainContent>
      },
      {
        path: '/backend',
        element: <HomeMainContent></HomeMainContent>
      }
    ]
  }
])

export default router
```

怎么让根路径匹配APP显示的时候包含自己的子组件？让根路径的有一个空路径匹配就可以了！！！

## 疑问：怎么将鼠标经过的时候菜单变色封装为一个hook





## 解决：OutLet组件所在的父组件需要传递数据给OutLet跳转后的组件，怎么传递？

使用useContext-----类似Vue3的依赖注入

```
1.首先，你需要创建这个 context，并 将其从一个文件中导出，这样你的组件才可以使用它：
import { createContext } from 'react';

export const LevelContext = createContext(1);

2.从 React 中引入 useContext Hook 以及你刚刚创建的 context:
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}

3.把它们用 context provider 包裹起来  以提供 LevelContext 给它们：
import { LevelContext } from './LevelContext.js';

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

## CSS头像剪裁

```css
.pinscomment__img--header {
  width: 4rem;
  height: 4rem;
  border-radius: 50%;
}
```

